# 第2章 Cortex-M3 处理器

## 2.1 简介

Cortex-M3 内核基于哈佛结构的三级流水线，采用ARM V7-M架构，使用Thumb-2指令集。

### 2.1.1 Cortex-M3 处理器的组件

1. **Cortex-M3 内核**

   32位处理器内核，拥有独立的指令总线和数据总线，指令和数据访问可以同时进行，单指令和数据共享同一个存储空间，寻址能力为4GB。

   - 采用ARM V7-M 架构，包括所有的Thumb指令集和基本的32位Thumb-2指令集架构。不能处理ARM指令。Thumb指令集是ARM指令集的子集，重新被编码为16位，支持较高的代码密度。
   - 哈佛处理器架构
   - 三级流水线
   - 32位单周期乘法，硬件除法指令：SDIV和UDIV。
   - 具有分组的堆栈指针（SP）
   - 处理模式(handler mode)和线程模式(thread mode)
   - Thumb状态和调试状态

2. **嵌套向量中断控制器(Nested Vector Interrupt Controller, NVIC)**：Cortex-M3 内建的中断控制器，与CPU紧密耦合，包含众多控制寄存器，支持中断嵌套模式，提供向量中断处理机制等等功能。

   - 外部中断可配置为1~240个
   - 优先级位可配置为3~8位
   - 支持电平和边沿中断
   - 中断优先级可动态地重新配置
   - 优先级分组，分为占先中断等级和非占先中断等级
   - 支持咬尾技术(tail-chaining)和迟来中断(late arrival)，这样两个中断之间没有多于状态保存和恢复指令的情况下，能背对背中断(back-to-back interrupt)处理
   - 处理器 状态在进入中断时自动保存，中断退出时自动恢复，不需要多余的指令

3. **系统时钟(systick)**：24位倒计时计时器，可以产生定时中断，作为系统定时器使用，即使系统处于睡眠模式，该计数器也能正常工作。

4. **总线矩阵**：用来将处理器和调试接口与外部总线相连，是一个32位的AMBA AHB Lite 总线互联网络。总线矩阵把处理器内核及调试接口连接到不同类型和功能的外部总线，从而提供数据在不同总线上的并行传输功能。此外，总线矩阵还提供了附加数据传送功能，支持非对齐数据访问。

   - 非对齐访问：总线矩阵将非对齐的处理器访问转换为对齐访问。
   - 位带(bit-banding)支持：总线矩阵将位带别名访问转换为对位带区的访问，可以对位带加载进行位域提取，对位带存储区进行原子读-修改-写。

5. **寄存器**：包含13个通用的32位寄存器(R0~R12)、链接寄存器(LR)、程序计数器(PC)、程序状态寄存器(xPSR)、两个分组的SP寄存器。

6. **内存保护单元(MPU)**

### 2.1.2 总线结构

- **AHB(Advanced High performance Bus)系统总线**：主要用于高性能模块之间的连接
- **APB(Advanced Peripheral Bus)外设总线**：主要用于低带宽外设之间的连接。

Cortex-M3 通过总线矩阵对外设提供了系统总线、I-Code指令总线、D-Code数据总线、外设总线等。

- **I-Code 指令总线**：用于从代码空间中取指令和向量，默认映射到`0x00000000~0x1FFFFFFF`。读指以字方式操作，每次取4B长度的指令，一次可以取出2条16位的Thumb指令，
- **D-Code 总线**：用于对代码空间进行数据加载/存储以及调试访问，默认映射到`0x10000000~0x1FFFFFFF`。地址总线上总是对齐的地址，非对齐的数据传送都将转换成多次对齐的数据传送，然后拼装成所需的数据。
- **系统总线**：用于访问内存和外设，即SRAM、片上外设、片外RAM、片外扩展设备及系统级存储区。默认映射到`0x20000000~0xDFFFFFFF`和`0xE0100000~0xFFFFFFFF`两个地址段，所有数据传输都是对齐的。
- **外设总线（PPB总线）**：用于访问专用外设，默认映射到`0xE0040000~0xE00FFFFF`。常用AHB-APB桥实现内核内部高速总线到外部低速总线的数据缓冲和转换。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.1.png" alt="图 2.1" style="zoom:50%;" />

## 2.2 流水线

<img src="./Images/第2章 Cortex-M3 处理器/图 2.2.png" alt="图 2.2" style="zoom:50%;" />

当遇到分支、异常或断点时，之前执行的流水线取指和译码结果会被丢弃，直接跳转到相应的指令处取指，开始新的流水线，这叫流水线的清洗。

读取PC时，会返回**当前指令地址+4**的值，这个偏移量总是4，不管执行16位指令还是32位指令。

## 2.3 寄存器

`R1~R7`**低组寄存器**，`R8~R12`**高组寄存器**。绝大多是16位指令只能使用低组寄存器，32位Thumb-2指令可以访问所有通用寄存器。R13作为**堆栈指针(SP)**使用，R14是**链接寄存器(LR)**，R15是**程序计数器(PC)**。以上是通用寄存器。特殊功能寄存器包含**程序状态寄存器**、**中断屏蔽寄存器**和**控制寄存器**。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.3.png" alt="图 2.3" style="zoom:50%;" />

### 2.3.1 通用寄存器

1. **低组寄存器(R0~R7)**

   所有指令均能访问，字长32位，复位后初始值随机，绝大多数16位Thumb指令只能访问R0~R7。

2. **高组寄存器(R8~R12)**

   只有少数16位Thumb指令能访问，32位不受限制，字长为32位，复位后初始值随机。

3. **堆栈寄存器(R13)**

   **Stack Point, SP**。R13映射到两个堆栈指针，分别为

   - **主堆栈指针(MSP)**，默认堆栈指针，由OS内核、异常服务例程以及所有需要特权访问的应用程序代码来使用。
   - **进程堆栈指针(PSP)**，常规的用户应用程序代码使用。

   当R13使用时，只能使用当前系统状态确定的堆栈，另一个堆栈寄存器只能通过特殊指令MRS和MSR访问。

4. **链接寄存器(R14)**

   **Link Register, LR**。LR寄存器用于在调用子程序时存储返回地址。Cortex-M3 为减少访问内存的次数，把返回地址直接存储在链接寄存器R14中而不是放在内存的堆栈中，对于只用一级子程序调用时，不需要访问堆栈内存就可以返回到主调用程序。

5. **程序计数器(R15)**

   **Program Counter, PC。**用于指明当前的指令地址，如果向PC中写数据，则会引起一次程序的跳转，改变程序的执行流，但此时不更新LR寄存器。

   PC的第0位(LSB)用于指示ARM/Thumb 状态，0表示当前指令环境处于ARM状态，而1表示Thumb。

### 2.3.2 特殊功能寄存器

<img src="./Images/第2章 Cortex-M3 处理器/图 2.4.png" alt="图 2.4" style="zoom:50%;" />

```assembly
MRS <reg>,<special_reg> ;将特殊功能寄存器的值读到通用寄存器
MSR <special_reg>,<reg> ;将通用寄存器的值写到特殊功能寄存器
```



1. **程序状态寄存器(PSR, xPSR)**

   是一个32位寄存器，用于指示程序的运行状态，可分为3个子寄存器。

   <img src="./Images/第2章 Cortex-M3 处理器/图 2.5.png" alt="图 2.5" style="zoom:50%;" />

   **应用程序PSR(APSR)**：27~31位，包含代码条件标志。

   **中断号PSR(IPSR)**：0~8位，包含当前激活的ISR编号。

   **执行PSR(EPSR)**：`10~15`位和`24~26`位。

   MRS/MSR 指令可以对这三个寄存器单独访问或组合访问，当用三合一方式访问时，用xPSR进行统称。

   各标志位定义如下

   - **N——负数或小于(Negative)**。1：运算结果为负数或小于；0：运算结果为正数或大于。
   - **Z——零标志(Zero)**。1：运算结果为0；0运算结果为非0.
   - **C——进位/借位标志(Carry)**。1：运算过程产生进位或借位；0：运算过程没有进位或借位。
   - **V——溢出标志(oVerflow)**。1：溢出；0：没有溢出。
   - Q——粘着饱和。没用到

   EPSR包含两个重叠的区域

   - **可中断-可继续指令(ICI)区**——多寄存器加载(LDM)和存储(STM)操作是可中断的。ICI用来保存从产生中断的点继续执行多寄存器加载和存储操作时所必须的信息。ICI就是可中断-可继续的指令位。如果执行LDM或STM产生中断，则操作暂停，EPSR使用位`[15:12]`来保存该操作中下一个寄存器操作数编号，中断响应后，返回由`[15:12]`指向的寄存器并恢复操作，如果ICI指向的寄存器不在指令的寄存器列表中，则对列表中下一个寄存器继续执行LDM/STM操作。
   - **If-Then 状态区**——EPSR的IT区包含了If-Then 指令的执行状态位，包含If-Then 模块的指令数目和它们的执行条件。ICI区和IT区是重叠的，If-Then 模块内的多寄存器加载或存储操作不具有可中断-可继续功能。
   - **T**——用于指示处理器当前是ARM 状态还是Thumb 状态，Cortex-M3 一直为1。

   用户不能直接访问EPSR，想修改需要发生以下两个事件之一：

   - 在执行LDM或STM指令时产生一次中断
   - 执行If-Then 指令

2. **中断屏蔽寄存器(PRIMASK, FAULTMASK, BASEPRI)**

   这三个寄存器用于控制异常的允许和禁止

   <img src="./Images/第2章 Cortex-M3 处理器/图 2.6.png" alt="图 2.6" style="zoom:50%;" />

   只有在特权级才允许访问这三个寄存器。

   为了快速开关中断，还有CPS指令

   ```assembly
   CPSID I	;PRIMASK = 1,关中断
   CPSIE I	;PRIMASK = 0,开中断
   CPSID F	;FAULTMASK = 1,关异常
   CPSIE F	;FAULTMASK = 0,开异常
   ```

   

3. **控制寄存器(CONTROL)**

   只使用最低两位，用于定义特权级别和选择当店使用哪个堆栈指针

   <img src="./Images/第2章 Cortex-M3 处理器/图 2.7.png" alt="图 2.7" style="zoom:50%;" />

   - **CONTROL[1]**:在Cortex-M3 的处理模式中，CONTROL[1]总是0，在线程模式中可以为0(特权级)或1(用户级)
   - **CONTROL[0]**:仅当处于特权级下操作才允许改写该位，一旦进入用户级，唯一返回特权级的途径就是触发中断异常，再由中断服务例程改写该位。

## 2.4 工作模式和工作等级

<img src="./Images/第2章 Cortex-M3 处理器/图 2.8.png" alt="图 2.8" style="zoom:50%;" />

运行主程序时，可以使用特权级或用户级；但异常服务例程必须在**特权级**下执行。复位后处理器默认进入**线程模式**，特权级访问。特权级下，程序可以访问所有范围的存储器，并且可以执行所有指令。而用户级下对某些资源的访问会受到限制或不允许访问。

特权级下可以通过置位CONTROL[0]进入用户级，产生异常后以特权级运行服务例程，异常返回后回到**异常工作前的工作级**。用户级不能通过修改CONTROL[0]来回到特权级。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.9.png" alt="图 2.9" style="zoom:50%;" />

## 2.5 堆栈

由一块连续的内存以及一个栈顶指针组成，先进后出。

### 2.5.1 堆栈的基本操作

堆栈地址由专门的寄存器——堆栈指针(SP)给出。

Cortex-M3 使用“**向下生长的满栈**”模型。堆栈按字操作，即每次入栈和出栈都是32位数据，所以SP值总是执行自增4/自减4操作。堆栈指针指向最后一个被压入堆栈的32位数值。

Cortex-M3 采用PUSH指令和POP指令进行入栈和出栈操作。PUSH操作时，**SP先自减4**，再**存入数据**到SP所指存储器位置；POP操作正好相反，先从SP所指存储器位置**读出数据**，**SP再自增4**。

```assembly
PUSH {R0}	;首先R13<-R13-4，然后存储器单元[R13]<-R0
POP {R0}	;首先R0<-存储器单元[R13]，然后R13<-R13+4
```

<img src="./Images/第2章 Cortex-M3 处理器/图 2.10.png" alt="图 2.10" style="zoom:50%;" />

### 2.5.2 Cortex-M3 的双堆栈机制

Cortex-M3 的堆栈有两个：主堆栈(MSP)和进程堆栈(PSP)，都被称为R13，在程序中可以通过MRS/MSR指令设置CONTROL[1]来指定选用的堆栈指针。

- 当CONTROL[1]=0时，只是用MSP，此时用户程序和异常处理共享一个堆栈，也是复位后默认使用方式。

  <img src="./Images/第2章 Cortex-M3 处理器/图 2.11.png" alt="图 2.11" style="zoom:50%;" />

- 当CONTROL[1]=1时，线程模式使用的是进程堆栈(PSP)，进入异常服务例程后自动改为MSP，退出异常时切换为PSP，并从进程堆栈上弹出数据。

  <img src="./Images/第2章 Cortex-M3 处理器/图 2.12.png" alt="图 2.12" style="zoom:50%;" />

通过读取PSP的值，操作系统就能获取用户应用程序使用的堆栈，进而知道发生异常时被压入堆栈的寄存器内容。

## 2.6 存储器管理

Cortex-M3 存储器管理有如下特点：

- 存储器映射是预定义的，而且还规定好了哪个位置使用哪条总线
- 支持位带操作，可以对单一比特（某个位）进行原子操作
- 支持非对齐访问和互斥访问
- 支持小端模式和大端模式

<img src="./Images/第2章 Cortex-M3 处理器/图 2.13.png" alt="图 2.13" style="zoom:50%;" />

Cortex-M3 通过存储器映射，使得所有设备使用固定的地址，从而保证至少在内核水平上，方便了不同种类Cortex-M3 之间的代码移植。

### 2.6.1 存储器空间分配

1. **代码区(`0x00000000~0x1FFFFFFF`，共512MB)**：主要用于存放程序代码。
2. **片上SRAM区(`0x20000000~0x3FFFFFFF`，共512MB)**：用于让芯片制造商连接片上的SRAM，这个区域通过系统总线访问，该区最底部1MB地址范围为位带区(`0x20000000~0x200FFFFF`)，可存放8MB变量。与此对应，还有一个32MB的位带别名(Alias)区(`0x22000000~0x23FFFFFF`)，用一个字(4B)代表每一个位带区中的每一个位。这样对位带别名区中每一个字进行读写时，实际上就是对位带区的每一个位进行读写。
3. 片上外设区(`0x40000000~0x5FFFFFFF`，共512MB)：主要由片上外设区使用，用于映射片上外设寄存器，同样，该区也有一个32MB的位带别名区，便于快捷访问外设寄存器。外设区不允许执行指令。
4. 外部RAM区(`0x60000000~0x9FFFFFFF`，共1GB)和外部设备区(`0xA0000000~0xDFFFFFFF`，共1GB)：外部RAM区用于连接外部RAM，外部设备区用于连接外部设备。这两个存储区不包含位带，两者的区别在于外部RAM区允许执行指令，而外部设备区不允许。
5. 专用外设总线区(`0xE0000000~0xE00FFFFF`)：专用外设总线区由连部分组成：内部专用外设区(`0xE0000000~0xE003FFFF`，共256KB)和外部专用外设区(`0xE0040000~0xE00FFFFF`，共768KB)。AHB专用外设总线，对应于内部专用外设区只用于Cortex-M3内部AHB外设。APB专用外设总线对应于外部专用外设区，用于Cortex-M3 内部APB设备。
6. 芯片厂商指定区：芯片厂商指定区也通过系统总线来访问，但是不允许在其中执行指令。

### 2.6.2 位带操作

<img src="./Images/第2章 Cortex-M3 处理器/图 2.14.png" alt="图 2.14" style="zoom:50%;" />

在Cortex-M3 中，有两个区实现了位带：内部SRAM区的最低1MB空间，另一个是片上外设区的最低1MB空间。这两个区中的地址除了可以像普通RAM一样使用外，还都有自己的位带别名区。位带别名区把每位膨胀成一个32位的字，当访问位带别名区的字时，就像访问原始比特一样。

支持位带区操作的两个内存区范围如下：

- `0x20000000~0x200FFFFF`（内部SRAM区中的最低1MB）
- `0x40000000~0x400FFFFF`（片上外设区中的最低1MB）

在位带区中，每一位都映射到位带别名区的一个字(32位)，该字只有最低位有效。当一个别名地址被访问时，会把该地址变换成位带地址。对于读操作，读取位带地址中的一个字，再把需要的位右移到最低位返回。对于写操作，把需要写的位左移对应的位序号处，然后执行不会被中断的“读-改-写”过程。

对于内部SRAM位带区的某个位，记住它所在字节地址位A，位序号为n($0\leqslant n\leqslant 7$)，则该比特所在别名区的地址为
$$
\begin{aligned}
\mathrm{AliasAddr}&=0\mathrm{x}22000000+((A-0\mathrm{x}20000000)\times 8+n)\times4\\
&=0\mathrm{x}22000000+(A-0\mathrm{x}20000000)\times 32+n\times4\\
\end{aligned}
$$
对于片内外设位带区的某个位，地址为
$$
\begin{aligned}\mathrm{AliasAddr}&=0\mathbf{x}42000000+((A-0\mathbf{x}40000000)\times8+n)\times4\\&=0\mathbf{x}42000000+(A-0\mathbf{x}400000000)\times32+n\times4\end{aligned}
$$
乘4是因为一个字为4字节，乘8是因为一个字节表示8位。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.15.png" alt="图 2.15" style="zoom:50%;" />

### 2.6.3 端模式

一般Corte-M3采用小端模式，即数据的高位字节保存在高位地址。

## 2.7 异常与中断

**中断**是计算机在执行程序过程中，出现某些事件需要立即处理时，CPU暂时中止正在执行的任务，转去执行对某种请求的处理程序。当处理程序执行完毕后，CPU在回到先前被暂时中止的程序继续执行。实现这种功能的部件称为**中断系统**，请示CPU中断的请求称为**中断源**。中断源向CPU发出中断申请，CPU暂停当前工作转去处理中断事件称为**中断响应**，对整个事件的处理过程称为中断服务，事件处理完毕CPU返回到被中断的地方称为**中断返回**。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.16.png" alt="图 2.16" style="zoom:50%;" />

计算机中断系统一般允许多个中断源，但是存在优先级别，先响应优先级高的中断请求。低级中断可以被高级终端打断，称为中断嵌套。

中断和调用子程序之间的区别：

<img src="./Images/第2章 Cortex-M3 处理器/图 2.17.png" alt="图 2.17" style="zoom:50%;" />

几个相关概念

- **开中断和关中断**

  可以通过指令设置相关特殊功能寄存器的内容来实现，这是CPU能否接收中断请求的关键

- **堆栈**

  主程序调用子程序或中断处理过程时，分别要**保存返回地址**和**保护现场**，以便返回时能够回到调用前的程序段，继续运行原来程序。

  在进入子程序或中断处理程序后，还需要保护子程序或中断处理程序所用到的**通用寄存器中的数据**。进入子程序或中断处理程序后还要保护这些寄存器中的值，叫做**保护现场**；子程序返回或中断处理返回前，还要能够恢复这些寄存器中的值，叫做**恢复现场**。

  **保存返回地址**的方法是将返回地址保存到堆栈中，返回主程序前从堆栈中**取出上述地址**放回指令计数器（PC）中，按照放回后的PC值，从程序存储器中取指令就返回到了主程序中被中断的地方，以继续执行主程序。

  **保护现场**的方法是将现场条件（寄存器的值）先推入堆栈保存，然后再使用这些寄存器，返回主程序前，弹出寄存器的值。

  通用寄存器的保存和恢复需要由堆栈指令来完成；返回地址的保存于恢复的堆栈操作都是在相应的子程序的调用和返回命令的操作中自动完成的，无需再用专门的堆栈指令操作。

- **中断的响应**

  CPU相应中断源请求时，由中断系统硬件控制CPU从主程序转去执行中断服务程序，同时把断电地址自动送入堆栈进行保护，以便执行完中断服务程序后能够返回到原来的断点继续执行主任务。

- **中断的撤除**

  响应中断请求后，返回主程序之前，该中断请求标志应该撤除，否则CPU执行完中断服务程序会误判为又发生了中断请求而错误地再次进入中断服务程序。

  Cortex-M3将**外部中断、SVC和Reset**均称为**异常**。Cortex-M3内核集成了中断控制器——**嵌套向量中断控制器**(Nested Vectored Interrupt Controller, NVIC)，具有以下功能

  - **可嵌套中断支持**：通过赋予中断优先级提供可嵌套中断支持。
  - **向量中断支持**：中断发生并开始相应后，Cortex-M3 自动定位一张向量表，并根据中断号从表中找出中断服务程序ISR的入口地址，然后跳转过去并执行。
  - **动态优先级调整支持**：软件可以在运行时期更改中断的优先级
  - **中断延迟大大缩短**：Cortex-M3 有自动的现场保护和恢复、咬尾机制和晚到异常处理等措施，缩短中断嵌套的时间延迟。
  - **中断可屏蔽**：可以屏蔽优先级低于某个阈值的中断，也可也全部屏蔽，以此让时序要求苛刻的任务能在截止期之前完成而不被干扰。
  
  Cortex-M3 内核中NVIC支持256种异常和中断，编号为1~15的对应系统异常，大于或等于16的全是外部中断，写作**IRQ**。NVIC访问地址为`0xE000E000`，除软件触发中断寄存器可以在**用户级**下访问外，其他所有NVIC的中断控制/状态寄存器都只能在**特权级**下访问。所有中断控制/状态寄存器均可按字/半字/字节的方式访问。
  

### 2.7.1 中断号与优先级

<img src="./Images/第2章 Cortex-M3 处理器/图 2.18.png" alt="图 2.18" style="zoom:50%;" />

<img src="./Images/第2章 Cortex-M3 处理器/图 2.19.png" alt="图 2.19" style="zoom:50%;" />

**优先级数值越小，优先级越高**，高优先级异常可以抢占低优先级异常，三个系统异常有固定优先级，负数，高于其他所有优先级，其他异常优先级可编程，但是**不能为负数**。芯片设计时会裁掉表达优先级的几个低端有效位，Cortex-M3 允许使用的最小位数为3位，至少支持8个优先级。3位优先级与4位的区别如下。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.20.png" alt="图 2.20" style="zoom:40%;" />

除了配置优先级之外，还把优先级分为抢占优先级和副优先级，抢占优先级决定了抢占行为，副优先级处理“内务”，即当抢占优先级相同的异常不止有一个挂起时，在当前任务完成后就**优先响应副优先级最高的异常**。优先级分组规定，副优先级至少是一位，抢占优先级最多是七位。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.21.png" alt="图 2.21" style="zoom:50%;" />

NVIC种有一个应用程序中断及复位控制寄存器(AIRCR)，它里面有一个位段名为优先级分组(PRIGROUP)，其值对每一个优先级可配置的异常都有影响，具体内容如下

<img src="./Images/第2章 Cortex-M3 处理器/图 2.22.png" alt="图 2.22" style="zoom:50%;" />

例如用3位来表示抢占优先级，且优先级组值是5，意味着优先级从bit5开始分组，则可以得到四级抢占优先级和8级副优先级

<img src="./Images/第2章 Cortex-M3 处理器/图 2.23.png" alt="图 2.23" style="zoom:50%;" />

<img src="./Images/第2章 Cortex-M3 处理器/图 2.24.png" alt="图 2.24" style="zoom:40%;" />

### 2.7.2 向量表

向量表用于在发生中断并做出响应时，从表中查询与中断对应的处理例程的入口。默认情况下，该表位于零地址处，各向量占用4字节。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.25.png" alt="图 2.25" style="zoom:50%;" />

Cortex-M3 允许向量表重定位——从其他地址开始定位各异常向量，这些地址对应的区域可以是代码区，也可以是RAM区。RAM区可以修改向量的入口地址。NVIC中有一个向量表偏移量寄存器(VTOR)(在地址`0xE000ED08`)，通过修改它的值就能定位向量表。但是向量表的起始地址需要是2的整数次幂的边界。如系统有32个中断，加上16个异常则共有48个变量，则地址需要增大到64，必须能被$64\times 4=256$整除，所以合法的起始地址可以为`0x0`，`0x100`，`0x200`。向量偏移寄存器定义如下

<img src="./Images/第2章 Cortex-M3 处理器/图 2.26.png" alt="图 2.26" style="zoom:50%;" />

如果需要动态更改向量表，向量表的起始处需要包含

- 主堆栈指针(MSP)的初始值
- 复位向量
- NMI
- 硬Fault服务例程

### 2.7.3 中断输入及挂起

<img src="./Images/第2章 Cortex-M3 处理器/图 2.27.png" alt="图 2.27" style="zoom:50%;" />

当某中断的服务例程开始执行时，此中断进入“活跃”状态，并且挂起标志会被硬件自动清除.中断服务例程执行完毕并返回中断后,才能对该中断的新请求予以响应.新请求的响应也是由硬件自动清零挂起标志位,中断服务例程也可以在执行过程中把自己对应中断重新挂起.

如果中断请求信号已知保持,那该中断就会在其上次服务例程返回后再次被置为挂起状态.

<img src="./Images/第2章 Cortex-M3 处理器/图 2.28.png" alt="图 2.28" style="zoom:50%;" />

如果某个中断在得到响应前，请求信号以多个脉冲形式呈现，则被视为只有一次中断请求。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.29.png" alt="图 2.29" style="zoom:50%;" />

如果服务例程执行时，中断请求释放了，但是在服务例程返回前又重新被置为有效，则Cortex-M3 会记住此动作，重新挂起该中断。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.30.png" alt="图 2.30" style="zoom:50%;" />

### 2.7.4 Fault类异常

Cortex-M3 中的Fault可分为以下几类

1. **总线Fault**。当AHB接口上正在传送数据时，如果回复了一个错误信号，则会产生总线Fault，如指令预取中止、数据读写中止等。
2. **存储器管理Fault**：诱因常常是某次访问触犯了MPU设置的保护策略，另外某些非法访问也会触发该Fault，如不可执行的存储器区域试图取指(没有MPU也会触发),以及访问了MPU设置区域覆盖范围之外的地址、访问了没有存储器与之对应的空地址、只读区域写数据、用户状态下访问了只允许在特权级下访问的地址等。
3. **用法Fault**：若执行了未定义的指令、执行了协处理器指令、尝试进入ARM状态、存在无效的中断返回、使用多重加载/存储指令时以及没有对齐地址时都会触发用法Fault。
4. **硬Fault**：是上面Fault上访的结果，如果这些Fault服务例程无法执行，它们就会成为“硬伤”。在取向量时产生的总线Fault也按硬Fault处理。NVIC中有一个硬Fault状态寄存器(HFSR)，由它指出产生硬Fault的原因。

对于Fault的常用方法

- **复位**：设置NVIC应用程序中断及复位控制寄存器中的VECTRESET位，将只复位处理器内核而不复位其他片上设施。
- **恢复**
- **中止相关任务**

各个Fault状态寄存器(FSR)都会保持住它的状态，直到手工清除为止。

### 2.7.5 中断的具体行为

当Cortex-M3 响应一个中断时，将依次执行以下操作

- **取向量**：从向量表上找出对应服务程序入口地址
- 选择堆栈指针MSP/PSP，更新堆栈指针(SP)，更新连接寄存器(LR)，更新程序计数器(PC)
- **入栈操作**：自动保存现场是入栈操作的必要部分，即依次把xPSR,PC,LR,R12以及R3~R0共8个寄存器内容由硬件自动压入适当的堆栈中。当响应异常时，如果当前的代码正在使用PSP，则压入PSP，即使用线程堆栈；否则压入MSP，使用主堆栈。一旦进入了服务例程，就将一直使用主堆栈。

操作过程如下

1. **取向量**：当数据总线(系统总线)开始入栈操作时,指令总线(I-Code 总线)也启动响应中断流程,开始从向量表中找出正确的异常向量,随后在中断服务程序的入口处预取指令。此时，入栈与取指这两个工作能同时进行。
2. **更新寄存器**：在入栈和取向量操作完毕、中断服务例程执行之前,有些寄存器的内容需要更新。
   - **SP**:在入栈中会把堆栈指针(PSP或MSP)更新到新的位置,在执行服务程序例程后,将由MSP负责对堆栈的访问
   - **PSR**:IPSR位段(PSR的最低部分)会被更新为新响应的异常编号
   - **PC**:在向量取出完毕后,PC将指向服务例程的入口地址
   - **LR**:LR的用法将会被重新解释,其值也被更新成一种特殊的值,称为“EXRETURN”,并且在异常返回时使用。EXRETURN的二进制值除了最低4位外全为1,而其最低4位则有特殊含义。
3. **异常返回**：在异常服务例程执行完毕后,借助“异常返回”操作恢复先前的系统状态,使先前被中断的程序得以继续执行。有3种途径可以触发异常返回操作，不管使用哪一种,都需要用到先前存储的LR值。
4. **出栈**：恢复压入栈中的寄存器内容，内容的出栈顺序与入栈时相对应，堆栈指针的值也改回去。
5. **更新NVIC寄存器**：中断返回后，NVIC的活动位也被硬件清除。

对于外部中断，若终端输入再次被置位为有效，挂起位也将再次置位，新一次的中断响应序列也将再次开始。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.31.png" alt="图 2.31" style="zoom:50%;" />

### 2.7.6 中断嵌套机制

1. 通过对NVIC以及Cortex-M3 处理器相关寄存器的设置，可以方便地确定中断源的优先级。系统正在响应某个异常时，所有优先级不高于它的异常都不能抢占。
2. 自动入栈和出栈能及时保护相关寄存器内容，不至于发生中断嵌套时寄存器内容受损。
3. 相同异常的不可重入特性：对于同一个异常，只有在上次实例的服务例程执行完毕后，方可继续响应新的请求。

### 2.7.7 高级中断技术

1. **咬尾技术**

   当处理器响应某异常时，如果又发生其他中断，若优先级不高，被阻塞，中断返回时正常操作流程如下

   - 执行**POP**操作以恢复系统现场
   - 系统处理挂起的异常
   - 执行**PUSH**操作以保护系统现场

   由于POP和PUSH涉及的系统现场是**一样**的，所以通过**继续使用上一个异常已经PUSH好的系统现场**，本次异常完成后才执行现场恢复操作。

   <img src="./Images/第2章 Cortex-M3 处理器/图 2.32.png" alt="图 2.32" style="zoom:50%;" />

2. **迟来异常**

   当Cortex-M3 对某异常的相应序列还在入栈阶段，且尚未执行其服务例程时，如果此时收到了高优先级异常的请求，则本次入栈就成为了高优先级中断所做的了，入栈后，**将执行高优先级异常的服务例程**。

   <img src="./Images/第2章 Cortex-M3 处理器/图 2.33.png" alt="图 2.33" style="zoom:50%;" />

### 2.7.8 异常返回值

进入异常服务程序后，LR的值被自动更新为特殊的EXC_RETURN，这是一个高28位全为1的值，只有位段`[3:0]`的值有特殊含义。当异常服务例程把这个值送到PC时，就会启动特殊处理器的中断返回序列。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.34.png" alt="图 2.34" style="zoom:50%;" />

合法的EXC_RETURN值共有3个

<img src="./Images/第2章 Cortex-M3 处理器/图 2.35.png" alt="图 2.35" style="zoom:50%;" />

如果主程序在线程模式下运行,并且在使用MSP时被中断,则在服务例程中`LR=0xFFFFFFF9`(主程序被打断前的LR已被自动入栈)。如果主程序在线程模式下运行,并且在使用PSP时被中断,则在服务例程中`LR=0xFFFFFFFD`(主程序被打断前的LR已被自动入栈)。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.36.png" alt="图 2.36" style="zoom:50%;" />

如果主程序在处理模式下运行,则在服务程序中`LR=0xFFFFFFF1`(主程序被打断前的LR已自动入栈),这时的“主程序”其实更可能是被抢占的服务例程。事实上,在嵌套时更深层ISR所看到的LR总是`0xFFFFFFF1`。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.37.png" alt="图 2.37" style="zoom:50%;" />

## 2.8 复位序列

Cortex-M3 处理器的程序映像是从地址`0x00000000`开始的，开始处为向量表

<img src="./Images/第2章 Cortex-M3 处理器/图 2.38.png" alt="图 2.38" style="zoom:50%;" />

每个中断向量的地址都等于异常号乘4，向量的最低位都被置1，表明异常处理执行时使用Thumb指令。例如，如果启动代码位于地址`0x00000100`，则地址`0x00000004`处的值被置为`0x00000101`。

向量表中还包含了主堆栈指针(MSP)的初始值，被存储在向量表的头四个字节。离开复位状态后,Cortex-M3做的第一件事就是从地址`0x00000000`处取出MSP的初始值(两个字,即8字节);从地址`0x00000004`处取出复位向量(PC的初始值,LSB必须是1),它表示程序执行的起始地址(复位处理),然后从这个值所对应的地址处取指。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.39.png" alt="图 2.39" style="zoom:50%;" />

复位流程会初始化主栈指针(MSP),假定内存位于`0x20000000~0x20007FFF`,可以将`0x20008000`写在地址`0x0000000`处,这样就实现了把主栈置于内存的顶部。在Cortex-M3中,在0地址处存放MSP的初始值,然后紧跟着就是向量表(向量表在以后还可以被移至其他位置)。向量表中的数值是32位的地址,而不是跳转指令。向量表的第一个条目指向复位后应执行的第一条指令所在的地址。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.40.png" alt="图 2.40" style="zoom:50%;" />

因为Cortex-M3使用的是向下生长的满栈,所以MSP的初始值必须是堆栈内存的末地址加1。举例来说,如果堆栈区域在`0x20007C00~0x20007FFF`之间,那么MSP的初始值必须是`0x20008000`。向量表跟随在MSP的初始值之后--也就是第2个表目。因为Cortex-M3是在Thumb态下执行,所以向量表中的每个数值都必须把LSB置1(也就是奇数),所以上图中使用`0x00000101`来表达地址`0x00000100`。当`0x00000100`处的指令得到执行后,就正式开始了程序的执行。在此之前初始化MSP是必需的,因为可能第1条指令还没来得及执行,就发生了不可屏蔽中断(NMI)或是其他Fault。MSP初始化好后就为它们的服务例程准备好了堆栈。

<img src="./Images/第2章 Cortex-M3 处理器/图 2.41.png" alt="图 2.41" style="zoom:33%;" />
